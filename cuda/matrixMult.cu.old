// Cmeated By:      Jacob Huckins & Mikey Thoreson
// Last Modified:   3/2/2025

#include <stdlib.h>
#include <stdio.h>
#include <cuda.h>
#include <cuda_runtime.h>

WINDOW_SIZE = 3;

// implementation taken from pg 109 of nvidia cuda C programming guide ver 4.2
__device__ double doubleAtomicAdd(double* address, double val)
{
	unsigned long long int* address_as_ull=
						(unsigned long long int*) address;
	unsigned long long int old=*address_as_ull, assumed;
	do {
		assumed = old;
		old = atomicCAS(address_as_ull, assumed,
				__double_as_longlong(val +
					__longlong_as_double(assumed)));
	} while (assumed!= old);
	return __longlong_as_double(old);
}

// comment

__device__ void sumVect(int **vA, int size, double *C)
{
    // get thread index
    int i = threadIdx.x;

    // skip out of bounds threads
    if (i >= size)
        return;

    // calulate the partial dot proudct
    double partial = *vA[i];

    // sum the partial answers together
    doubleAtomicAdd(C, partial);
}

__device__ void vectorDotProduct(int **vA, int **vB, int size, double *C)
{
    // get thread index
    int i = threadIdx.x;

    // skip out of bounds threads
    if (i >= size)
        return;

    // calulate the partial dot proudct
    double partial = *vA[i] * *vB[i];

    // sum the partial answers together
    doubleAtomicAdd(C, partial);
}
__device__ void vectorDotProduct(double **vA, double **vB, int size, double *C)
{
    // get thread index
    int i = threadIdx.x;

    // skip out of bounds threads
    if (i >= size)
        return;

    // calulate the partial dot proudct
    double partial = *vA[i] * *vB[i];

    // sum the partial answers together
    doubleAtomicAdd(C, partial);
}

//__global__ void naiveCorrelation(int *l, int *r, int width, int height, int pX, int pY, int rightOffset, int wSize, double *result)
//{
//    // calculate left - right and add up total error
//    int left[]
//    for (int x = -wSize; x < wSize; x++)
//    {
//        for (int y = -wSize; y < wSize; y++)
//        {
//            int i = x + y * wSize;
//
//            left[i] = l[(pX + x) + (y + pY) * wSize];
//            right[i] = r[(pX + x + offset) + (y + pY) * wSize];
//        }
//    }
//}

// run for each pixel to the left of the pixel to compare
__device__ void buildFrame(int ** img, int pX, int pY, int offset, int ** result){
    // we will accumulate the frame here, and copy it to the result later

    int frameIdx_X = threadIdx.x + (blockDim.x / 2) + pX + offset;
    int frameIdx_Y = threadIdx.y + (blockDim.y / 2) + pY;
    result[frameIdx_X + frameIdx_Y * blockDim.y] = img[frameIdx_X + frameIdx_Y * blockDim.y];
};
__device__ void correlationCoefficient(int **l_win, int **r_win, int size, double *out)
{
    // calc L dot 1
    double Ld1;
    sumVect<<<1, size>>>(l_win, size, &Ld1);

    // calc R dot 1
    double Rd1;
    sumVect<<<1, size>>>(r_win, size, &Rd1);

    // calc (L dot R) / N
    double LdR;
    vectorDotProduct<<<1, size>>>(l_win, r_win, size, &LdR);

    // calc (L dot L) / N
    double LdL;
    vectorDotProduct<<<1, size>>>(l_win, l_win, size, &LdL);

    // calc (R dot R) / N
    double RdR;
    vectorDotProduct<<<1, size>>>(r_win, r_win, size, &RdR);

    // calculate correlation coefficient
    // [n(X.Y) - (X.1)(Y.1)] / [(n(X.X) - X.1)(n(Y.Y - Y.1))]
    double top = size * LdR - Ld1 * Rd1;
    double bot = (size * LdL - Ld1) * (size(RdR - Rd1));

    double corCoef = top / bot;

    *out = corCoef;
}

// run for each pixel of the image
//__global__ void matchLR(int *l, int *r, int *out, int width, int height, int windowSize)
//{
//    int x = blockIdx.x * blockDim.x + threadIdx.x;
//    int y = blockIdx.y * blockDim.y + threadIdx.y;
//
//    // compute the correlation coefficient of the sliding the window frames
//    int threads = x; // number of windows to compare, only sliding left
//    double coefficients[threads] = {};
//    dim3 blockSize(threads);
//    dim3 gridSize(1);
//
//    correlationCoefficient<<blockSize, gridSize>>> (l, r, width, height, x, y, windowSize, &coefficients);
//
//    // find the offset that maximizes correlation
//    double max = 0;
//    int maxIndex = 0;
//    for (int i = i < threads; i++)
//    {
//        if (coefficients[i] < max)
//        {
//            max = coefficients[i];
//            maxIndex = i;
//        }
//    }
//
//    // use the calculated offset (maxIndex as pixel coords) to caluclate the distance
//}

// CUDA kernel to square an array
__global__ void matrixMult(int *a, int *b, int *out, int size)
{
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;

    int outIndex = x + y * size;

    // for position (3, 4) of the result,
    // multiply each element going left to right accross
    // the 3rd row of A and the 4th col of B and sum the results
    int outTotal = 0;
    for (int i = 0; i < size; i++)
    {
        int aInd = i + (y * size);
        int bInd = x + (i * size);
        outTotal += a[aInd] * b[bInd];
    }
    out[outIndex] = outTotal;
}


__device__ void findMaxCoCo (int **l, int **r, int pX, int pY, int windowSz, int row, int *retVal){
    int i = threadIdx.x;

    double* l_win[];
    if(i == 0){
        buildFrame<<<1, windowSz>>>(l, pX, pY, 0, l_win[]);
    }


   cudaDeviceSynchronize(); 


}

int main()
{
    //get 3d matrix of windows
    //get 2d matrix of max
}
